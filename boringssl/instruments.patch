diff --git a/include/openssl/curve25519.h b/include/openssl/curve25519.h
index a455389c..b6b9612d 100644
--- a/include/openssl/curve25519.h
+++ b/include/openssl/curve25519.h
@@ -41,6 +41,8 @@ extern "C" {
 // generated, publicâ€“private key pair.
 OPENSSL_EXPORT void X25519_keypair(uint8_t out_public_value[32],
                                    uint8_t out_private_key[32]);
+OPENSSL_EXPORT void X25519_keypair_client(uint8_t out_public_value[32],
+                                          uint8_t out_private_key[32]);
 
 // X25519 writes a shared key to |out_shared_key| that is calculated from the
 // given private key and the peer's public value. It returns one on success and
diff --git a/ssl/handshake_client.cc b/ssl/handshake_client.cc
index e46b39f9..9c584082 100644
--- a/ssl/handshake_client.cc
+++ b/ssl/handshake_client.cc
@@ -411,9 +411,14 @@ static enum ssl_hs_wait_t do_start_connect(SSL_HANDSHAKE *hs) {
     }
   }
 
+/*
   if (!RAND_bytes(ssl->s3->client_random, sizeof(ssl->s3->client_random))) {
     return ssl_hs_error;
   }
+*/
+  const char *client_random_override = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
+    "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f";
+  OPENSSL_memcpy(ssl->s3->client_random, client_random_override, sizeof(ssl->s3->client_random));
 
   // Initialize a random session ID for the experimental TLS 1.3 variant
   // requiring a session id.
@@ -425,9 +430,14 @@ static enum ssl_hs_wait_t do_start_connect(SSL_HANDSHAKE *hs) {
                    hs->session_id_len);
   } else if (hs->max_version >= TLS1_3_VERSION) {
     hs->session_id_len = sizeof(hs->session_id);
+/*
     if (!RAND_bytes(hs->session_id, hs->session_id_len)) {
       return ssl_hs_error;
     }
+*/
+    const char *fake_session_id_override = "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef"
+      "\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff";
+    OPENSSL_memcpy(hs->session_id, fake_session_id_override, hs->session_id_len);
   }
 
   if (!ssl_write_client_hello(hs)) {
diff --git a/ssl/internal.h b/ssl/internal.h
index 22189920..e634d620 100644
--- a/ssl/internal.h
+++ b/ssl/internal.h
@@ -960,6 +960,7 @@ class SSLKeyShare {
 
   // Offer generates a keypair and writes the public value to
   // |out_public_key|. It returns true on success and false on error.
+  virtual bool OfferClient(CBB *out_public_key) PURE_VIRTUAL;
   virtual bool Offer(CBB *out_public_key) PURE_VIRTUAL;
 
   // Accept performs a key exchange against the |peer_key| generated by |offer|.
diff --git a/ssl/ssl_key_share.cc b/ssl/ssl_key_share.cc
index 8466eabb..ec61e2be 100644
--- a/ssl/ssl_key_share.cc
+++ b/ssl/ssl_key_share.cc
@@ -72,6 +72,9 @@ class ECKeyShare : public SSLKeyShare {
 
     return true;
   }
+  bool OfferClient(CBB *out) override {
+    return Offer(out);
+  }
 
   bool Finish(Array<uint8_t> *out_secret, uint8_t *out_alert,
               Span<const uint8_t> peer_key) override {
@@ -165,6 +168,11 @@ class X25519KeyShare : public SSLKeyShare {
 
   uint16_t GroupID() const override { return SSL_CURVE_X25519; }
 
+  bool OfferClient(CBB *out) override {
+    uint8_t public_key[32];
+    X25519_keypair_client(public_key, private_key_);
+    return !!CBB_add_bytes(out, public_key, sizeof(public_key));
+  }
   bool Offer(CBB *out) override {
     uint8_t public_key[32];
     X25519_keypair(public_key, private_key_);
diff --git a/ssl/t1_lib.cc b/ssl/t1_lib.cc
index 678e4a3b..0b6f3b9b 100644
--- a/ssl/t1_lib.cc
+++ b/ssl/t1_lib.cc
@@ -2182,7 +2182,7 @@ static bool ext_key_share_add_clienthello(SSL_HANDSHAKE *hs, CBB *out) {
   if (!hs->key_share ||
       !CBB_add_u16(&kse_bytes, group_id) ||
       !CBB_add_u16_length_prefixed(&kse_bytes, &key_exchange) ||
-      !hs->key_share->Offer(&key_exchange) ||
+      !hs->key_share->OfferClient(&key_exchange) ||
       !CBB_flush(&kse_bytes)) {
     return false;
   }
diff --git a/ssl/tls13_server.cc b/ssl/tls13_server.cc
index 0d82d68b..b4fb87e7 100644
--- a/ssl/tls13_server.cc
+++ b/ssl/tls13_server.cc
@@ -178,6 +178,9 @@ static bool add_new_session_tickets(SSL_HANDSHAKE *hs, bool *out_sent_tickets) {
     if (!RAND_bytes((uint8_t *)&session->ticket_age_add, 4)) {
       return false;
     }
+    const char *session_ticket_age_add_override = "\x01\x02\x03\x04";
+    OPENSSL_memcpy(&session->ticket_age_add, session_ticket_age_add_override, 4);
+
     session->ticket_age_add_valid = true;
     if (ssl->enable_early_data) {
       session->ticket_max_early_data = kMaxEarlyDataAccepted;
@@ -560,12 +563,16 @@ static enum ssl_hs_wait_t do_read_second_client_hello(SSL_HANDSHAKE *hs) {
 static enum ssl_hs_wait_t do_send_server_hello(SSL_HANDSHAKE *hs) {
   SSL *const ssl = hs->ssl;
 
+  const char *server_random_override = "\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
+    "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f";
+  OPENSSL_memcpy(ssl->s3->server_random, server_random_override, sizeof(ssl->s3->server_random));
+
   // Send a ServerHello.
   ScopedCBB cbb;
   CBB body, extensions, session_id;
   if (!ssl->method->init_message(ssl, cbb.get(), &body, SSL3_MT_SERVER_HELLO) ||
       !CBB_add_u16(&body, TLS1_2_VERSION) ||
-      !RAND_bytes(ssl->s3->server_random, sizeof(ssl->s3->server_random)) ||
+      /* !RAND_bytes(ssl->s3->server_random, sizeof(ssl->s3->server_random)) || */
       !CBB_add_bytes(&body, ssl->s3->server_random, SSL3_RANDOM_SIZE) ||
       !CBB_add_u8_length_prefixed(&body, &session_id) ||
       !CBB_add_bytes(&session_id, hs->session_id, hs->session_id_len) ||
diff --git a/third_party/fiat/curve25519.c b/third_party/fiat/curve25519.c
index 58a5ed04..aca3f420 100644
--- a/third_party/fiat/curve25519.c
+++ b/third_party/fiat/curve25519.c
@@ -3175,6 +3175,9 @@ static void x25519_scalar_mult(uint8_t out[32], const uint8_t scalar[32],
 
 void X25519_keypair(uint8_t out_public_value[32], uint8_t out_private_key[32]) {
   RAND_bytes(out_private_key, 32);
+  const char *server_key_override = "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
+    "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf";
+  OPENSSL_memcpy(out_private_key, server_key_override, 32);
 
   // All X25519 implementations should decode scalars correctly (see
   // https://tools.ietf.org/html/rfc7748#section-5). However, if an
@@ -3196,6 +3199,19 @@ void X25519_keypair(uint8_t out_public_value[32], uint8_t out_private_key[32]) {
   X25519_public_from_private(out_public_value, out_private_key);
 }
 
+void X25519_keypair_client(uint8_t out_public_value[32], uint8_t out_private_key[32]) {
+  RAND_bytes(out_private_key, 32);
+  const char *client_key_override = "\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
+    "\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f";
+  OPENSSL_memcpy(out_private_key, client_key_override, 32);
+
+  out_private_key[0] |= ~248;
+  out_private_key[31] &= ~64;
+  out_private_key[31] |= ~127;
+
+  X25519_public_from_private(out_public_value, out_private_key);
+}
+
 int X25519(uint8_t out_shared_key[32], const uint8_t private_key[32],
            const uint8_t peer_public_value[32]) {
   static const uint8_t kZeros[32] = {0};
